<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <!-- æ ¸å¿ƒä¿®æ­£ï¼šviewport-fit=cover é€‚é…åˆ˜æµ·å± -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Web MOBA: å¾®ä¿¡é€‚é…ç‰ˆ</title>
    <style>
        * {
            touch-action: none; /* ç¦æ­¢æ»‘åŠ¨é¡µé¢ */
            -webkit-touch-callout: none; /* ç¦æ­¢é•¿æŒ‰å‘¼å‡ºèœå• */
            -webkit-user-select: none; /* ç¦æ­¢é€‰ä¸­æ–‡æœ¬ */
            user-select: none;
        }
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', sans-serif;
            color: white;
        }
        canvas { display: block; }

        /* UI è¦†ç›–å±‚ */
        .overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100;
        }
        .hidden { display: none !important; }
        
        h1 { font-size: 24px; color: #ffd700; margin-bottom: 20px; text-align: center; }
        
        /* è‹±é›„é€‰æ‹©å¡ç‰‡ */
        .hero-container { display: flex; gap: 15px; flex-wrap: wrap; justify-content: center; max-width: 90%;}
        .hero-card {
            width: 90px; background: #222; border: 2px solid #444; border-radius: 8px;
            padding: 10px; text-align: center; margin-bottom: 10px;
        }
        .hero-card:active { background: #444; border-color: #fff; }
        .hero-shape { width: 35px; height: 35px; margin: 0 auto 5px; display: flex; align-items: center; justify-content: center; font-size: 20px; }
        
        /* --- æ¸¸æˆå†… UI (å…³é”®ä¿®æ”¹ï¼šæ”¹ä¸º fixed å®šä½å¹¶è°ƒé«˜ä½ç½®) --- */
        
        /* é¡¶éƒ¨ä¿¡æ¯æ  */
        #hud-top {
            position: fixed; top: 10px; left: 0; width: 100%;
            display: flex; justify-content: space-between; 
            padding: 0 60px; /* ç•™å‡ºä¸¤è¾¹å®‰å…¨è·ç¦» */
            box-sizing: border-box;
            font-weight: bold; font-size: 12px; 
            pointer-events: none; z-index: 10;
            text-shadow: 1px 1px 2px black;
        }
        .team-blue { color: #4ecdc4; }
        .team-red { color: #e74c3c; }

        /* è¿”å›ä¸»é¡µæŒ‰é’® */
        #home-btn {
            position: fixed; top: 10px; left: 15px; z-index: 50;
            width: 35px; height: 35px;
            background: #333; border: 1px solid #666; border-radius: 5px;
            display: flex; align-items: center; justify-content: center;
            font-size: 20px; cursor: pointer; pointer-events: auto;
        }

        /* å·¦ä¾§æ‘‡æ† (ä½ç½®ä¸Šç§»ï¼Œé˜²æ­¢è¢«å¾®ä¿¡åº•éƒ¨æ é®æŒ¡) */
        #joystick-zone {
            position: fixed; 
            bottom: 60px; /* ä¸Šç§» */
            left: 30px;
            width: 140px; height: 140px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.1);
            pointer-events: auto;
            /* é€‚é… iPhone åº•éƒ¨æ¨ªæ¡ */
            margin-bottom: env(safe-area-inset-bottom); 
        }
        #joystick-stick {
            position: absolute; top: 50%; left: 50%;
            width: 50px; height: 50px;
            background: rgba(78, 205, 196, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        /* å³ä¾§æŠ€èƒ½ (ä½ç½®ä¸Šç§»ï¼Œç´§å‡‘æ’åˆ—) */
        #skill-zone {
            position: fixed; 
            bottom: 50px; /* ä¸Šç§» */
            right: 30px;
            display: flex; gap: 10px; align-items: flex-end;
            margin-bottom: env(safe-area-inset-bottom);
        }
        .mobile-skill-btn {
            width: 55px; height: 55px;
            background: #222; border: 2px solid #555; border-radius: 50%;
            color: white; font-size: 16px;
            display: flex; justify-content: center; align-items: center;
            position: relative;
            box-shadow: 0 4px 10px rgba(0,0,0,0.6);
            pointer-events: auto;
        }
        .mobile-skill-btn:active { background: #555; transform: scale(0.95); }
        .btn-r { width: 70px; height: 70px; border-color: #ffd700; background: #332a00; font-size: 20px; font-weight: bold;}
        
        .skill-cooldown {
            position: absolute; top:0; left:0; width: 100%; height: 100%;
            border-radius: 50%; background: rgba(0,0,0,0.7);
            display: none; justify-content: center; align-items: center;
            font-size: 18px; color: #fff;
        }

        /* ç«–å±æç¤º */
        #rotate-tip {
            display: none; position: fixed; top:0; left:0; width:100%; height:100%; 
            background: #000; z-index: 999; color: white; 
            align-items: center; justify-content: center; text-align: center; font-size: 20px;
        }
        @media screen and (orientation: portrait) { #rotate-tip { display: flex; } }
    </style>
</head>
<body>

    <!-- ç«–å±å¼ºåˆ¶æç¤º -->
    <div id="rotate-tip">è¯·å°†æ‰‹æœºæ¨ªå±<br>å¹¶å…³é—­å±å¹•é”å®š<br>ğŸ“±ğŸ”„</div>

    <!-- è‹±é›„é€‰æ‹© -->
    <div id="selection-screen" class="overlay">
        <h1>Webå³¡è°· - é€‰æ‹©è‹±é›„</h1>
        <div class="hero-container">
            <div class="hero-card" onclick="startGame('mage')">
                <div class="hero-shape" style="background:#3498db; border-radius:50%;">ğŸ”µ</div>
                <div>æ³•å¸ˆ</div>
            </div>
            <div class="hero-card" onclick="startGame('shooter')">
                <div class="hero-shape" style="background:transparent;"><div style="border-bottom: 25px solid #2ecc71; border-left: 12px solid transparent; border-right: 12px solid transparent;"></div></div>
                <div>å°„æ‰‹</div>
            </div>
            <div class="hero-card" onclick="startGame('warrior')">
                <div class="hero-shape" style="background:#e74c3c; width:25px; height:25px;"></div>
                <div>æˆ˜å£«</div>
            </div>
        </div>
    </div>

    <!-- æ¸¸æˆç»“æŸ -->
    <div id="end-screen" class="overlay hidden">
        <h1 id="end-msg">ç»“æŸ</h1>
        <div style="display: flex; gap: 20px;">
            <button class="hero-card" onclick="goHome()">æ›´æ¢è‹±é›„</button>
            <button class="hero-card" onclick="restartGame()">å†æ¥ä¸€å±€</button>
        </div>
    </div>

    <!-- æ¸¸æˆ HUD -->
    <div id="game-ui" class="hidden">
        <!-- è¿”å›ä¸»é¡µæŒ‰é’® -->
        <div id="home-btn" onclick="goHome()">ğŸ </div>

        <div id="hud-top">
            <div class="team-blue">æˆ‘å¡”: <span id="hp-blue-tower">5000</span></div>
            <div class="team-red">æ•Œå¡”: <span id="hp-red-tower">5000</span></div>
        </div>
        
        <!-- æ‘‡æ† -->
        <div id="joystick-zone">
            <div id="joystick-stick"></div>
        </div>

        <!-- æŠ€èƒ½ -->
        <div id="skill-zone">
            <div class="mobile-skill-btn" ontouchstart="handleSkillTouch(event, 'Q')">Q<div id="cd-q-mob" class="skill-cooldown"></div></div>
            <div class="mobile-skill-btn" ontouchstart="handleSkillTouch(event, 'W')">W<div id="cd-w-mob" class="skill-cooldown"></div></div>
            <div class="mobile-skill-btn" ontouchstart="handleSkillTouch(event, 'E')">E<div id="cd-e-mob" class="skill-cooldown"></div></div>
            <div class="mobile-skill-btn btn-r" ontouchstart="handleSkillTouch(event, 'R')">R<div id="cd-r-mob" class="skill-cooldown"></div></div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        // --- æ ¸å¿ƒé€»è¾‘ ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // å¼ºåˆ¶é‡ç½®ç”»å¸ƒå¤§å°ï¼Œè§£å†³å¾®ä¿¡æ˜¾ç¤ºé—®é¢˜
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // å…¨å±€å˜é‡
        let gameState = 'MENU';
        let animationId;
        let player, enemyHero, blueTower, redTower;
        let units = [], projectiles = [], effects = [], damageTexts = [];
        let joystick = { active: false, startX: 0, startY: 0, dx: 0, dy: 0, angle: 0 };
        let currentHeroType = 'mage'; // è®°å½•å½“å‰é€‰æ‹©çš„è‹±é›„ç±»å‹

        // é…ç½®
        const HERO_DATA = {
            mage: { type: 'mage', hp: 900, speed: 4.5, radius: 25, range: 220, icons: {Q:'ğŸ”¥', W:'âš¡', E:'ğŸ’¥', R:'ğŸŒŸ'}, cd: {Q:40, W:300, E:180, R:600} },
            shooter: { type: 'shooter', hp: 700, speed: 5.0, radius: 25, range: 380, icons: {Q:'ğŸ¹', W:'ğŸ‘Ÿ', E:'ğŸ”«', R:'ğŸ¯'}, cd: {Q:20, W:180, E:300, R:900} },
            warrior: { type: 'warrior', hp: 1600, speed: 4.8, radius: 30, range: 80, icons: {Q:'ğŸª“', W:'ğŸƒ', E:'ğŸŒªï¸', R:'ğŸŒ‹'}, cd: {Q:30, W:240, E:360, R:700} }
        };

        // --- æ¸¸æˆç±» ---
        class Unit {
            constructor(x, y, r, color, team, hp, maxHp) {
                this.x=x; this.y=y; this.radius=r; this.color=color; this.team=team;
                this.maxHp=maxHp||hp; this.hp=hp; this.dead=false;
            }
            drawHp(ctx) {
                const w=30, h=4;
                const pct = Math.max(0, this.hp/this.maxHp);
                ctx.fillStyle='#222'; ctx.fillRect(this.x-w/2, this.y-this.radius-10, w, h);
                ctx.fillStyle=this.team==='blue'?'#4ecdc4':'#e74c3c'; ctx.fillRect(this.x-w/2, this.y-this.radius-10, w*pct, h);
            }
            takeDamage(amt, isCrit=false) {
                if(this.dead) return;
                this.hp-=amt;
                damageTexts.push({x:this.x, y:this.y-30, n:amt, c:isCrit, life:30});
                if(this.hp<=0) { this.dead=true; this.hp=0; effects.push({x:this.x, y:this.y, r:this.radius*1.5, c:this.color, life:15, type:'explode'}); }
            }
        }

        class Hero extends Unit {
            constructor(x, y, team, config) {
                super(x, y, config.radius, team==='blue'?'#3498db':'#e74c3c', team, config.hp);
                this.config=config; this.facing=0; this.cds={Q:0,W:0,E:0,R:0,AA:0};
            }
            update() {
                for(let k in this.cds) if(this.cds[k]>0) this.cds[k]--;
            }
            cast(key, mx, my) {
                if(this.cds[key]>0) return;
                const a = Math.atan2(my-this.y, mx-this.x);
                const cfg = this.config;
                // æŠ€èƒ½é€»è¾‘ç®€åŒ–ç‰ˆ
                if(key==='Q') {
                     if(cfg.type==='warrior') { dealArea(this.x+Math.cos(a)*60, this.y+Math.sin(a)*60, 80, 100, this.team); effects.push({x:this.x, y:this.y, a:a, life:10, type:'slash'}); }
                     else projectiles.push({x:this.x, y:this.y, vx:Math.cos(a)*(cfg.type==='shooter'?18:12), vy:Math.sin(a)*(cfg.type==='shooter'?18:12), dmg:cfg.type==='shooter'?90:120, r:cfg.type==='shooter'?6:15, c:this.color, team:this.team, life:40});
                }
                else if(key==='W') {
                    let d = cfg.type==='warrior'?250:200;
                    this.x+=Math.cos(a)*d; this.y+=Math.sin(a)*d;
                    effects.push({x:this.x, y:this.y, r:30, c:'#fff', life:10, type:'explode'});
                }
                else if(key==='E') {
                    if(cfg.type==='mage') effects.push({x:mx, y:my, r:90, c:'#ffe66d', dmg:140, team:this.team, timer:40, done:false, type:'area'});
                    else if(cfg.type==='warrior') dealArea(this.x, this.y, 120, 60, this.team);
                    else { for(let i=-1;i<=1;i++) projectiles.push({x:this.x, y:this.y, vx:Math.cos(a+i*0.3)*12, vy:Math.sin(a+i*0.3)*12, dmg:40, r:5, c:this.color, team:this.team, life:30}); }
                }
                else if(key==='R') {
                    if(cfg.type==='mage') effects.push({x:this.x, y:this.y, a:a, dmg:350, team:this.team, life:15, type:'laser'});
                    else if(cfg.type==='warrior') effects.push({x:this.x, y:this.y, r:220, c:'#8B4513', dmg:350, team:this.team, timer:40, done:false, type:'area'});
                    else projectiles.push({x:this.x, y:this.y, vx:Math.cos(a)*35, vy:Math.sin(a)*35, dmg:450, r:10, c:'#f0f', team:this.team, life:50});
                }
                this.cds[key] = cfg.cd[key];
            }
            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y);
                ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(this.facing)*30, Math.sin(this.facing)*30); ctx.strokeStyle='rgba(255,255,255,0.5)'; ctx.stroke();
                ctx.fillStyle=this.color;
                if(this.config.type==='mage') { ctx.beginPath();ctx.arc(0,0,this.radius,0,Math.PI*2);ctx.fill(); }
                else if(this.config.type==='shooter') { ctx.beginPath();ctx.moveTo(15,0);ctx.lineTo(-10,10);ctx.lineTo(-10,-10);ctx.fill(); }
                else ctx.fillRect(-this.radius,-this.radius,this.radius*2,this.radius*2);
                ctx.restore(); this.drawHp(ctx);
            }
        }

        class Player extends Hero {
            update() {
                super.update();
                if(this.dead) return;
                if(joystick.active) {
                    this.x += joystick.dx * this.config.speed;
                    this.y += joystick.dy * this.config.speed;
                    this.facing = joystick.angle;
                    // è¾¹ç•Œé™åˆ¶
                    this.x = Math.max(20, Math.min(canvas.width-20, this.x));
                    this.y = Math.max(20, Math.min(canvas.height-20, this.y));
                }
                // è‡ªåŠ¨æ™®æ”»
                if(this.cds.AA<=0) {
                    let t = getNearest(this.x, this.y, this.config.range, this.team);
                    if(t) {
                         if(this.config.type==='warrior') { effects.push({x:this.x, y:this.y, a:Math.atan2(t.y-this.y, t.x-this.x), life:10, type:'slash'}); t.takeDamage(60); }
                         else projectiles.push({x:this.x, y:this.y, vx:Math.cos(Math.atan2(t.y-this.y, t.x-this.x))*9, vy:Math.sin(Math.atan2(t.y-this.y, t.x-this.x))*9, dmg:45, r:5, c:this.color, team:this.team, life:30});
                         this.cds.AA = this.config.type==='shooter'?25:50;
                    }
                }
                // æ›´æ–°UI
                ['Q','W','E','R'].forEach(k => {
                    const el = document.getElementById(`cd-${k.toLowerCase()}-mob`);
                    if(this.cds[k]>0) { el.style.display='flex'; el.innerText=Math.ceil(this.cds[k]/60); } else el.style.display='none';
                });
            }
        }

        // ç®€åŒ–çš„AIå’Œå¯¹è±¡
        function updateGame() {
            // å¡”ç”Ÿå…µ
            if(!blueTower.dead && ++blueTower.timer > 300) { for(let i=0;i<3;i++) units.push(new Unit(blueTower.x, blueTower.y+(i-1)*30, 10, '#4ecdc4', 'blue', 150)); blueTower.timer=0; }
            if(!redTower.dead && ++redTower.timer > 300) { for(let i=0;i<3;i++) units.push(new Unit(redTower.x, redTower.y+(i-1)*30, 10, '#ff6b6b', 'red', 150)); redTower.timer=0; }
            
            // å¡”æ”»å‡»
            [blueTower, redTower].forEach(t => {
                if(!t.dead && --t.atkTimer<=0) {
                    let target = getNearest(t.x, t.y, 400, t.team);
                    if(target) { projectiles.push({x:t.x, y:t.y, vx:Math.cos(Math.atan2(target.y-t.y, target.x-t.x))*8, vy:Math.sin(Math.atan2(target.y-t.y, target.x-t.x))*8, dmg:150, r:8, c:t.color, team:t.team, life:60}); t.atkTimer=60; }
                }
            });

            // AI è‹±é›„
            if(!enemyHero.dead) {
                enemyHero.update();
                let d = Math.hypot(player.x-enemyHero.x, player.y-enemyHero.y);
                let tx = enemyHero.x, ty = enemyHero.y;
                if(enemyHero.hp < enemyHero.maxHp*0.3) { tx = redTower.x; ty = redTower.y; }
                else if(d < 500) { tx = player.x; ty = player.y; if(Math.random()<0.02) enemyHero.cast('Q', player.x, player.y); }
                else { tx = redTower.x - 200; ty = redTower.y; }
                
                if(Math.hypot(tx-enemyHero.x, ty-enemyHero.y)>5) {
                    let a = Math.atan2(ty-enemyHero.y, tx-enemyHero.x);
                    enemyHero.x += Math.cos(a)*enemyHero.config.speed; enemyHero.y += Math.sin(a)*enemyHero.config.speed;
                }
                // AI æ™®æ”»
                if(enemyHero.cds.AA<=0 && d < enemyHero.config.range) {
                     projectiles.push({x:enemyHero.x, y:enemyHero.y, vx:Math.cos(Math.atan2(player.y-enemyHero.y, player.x-enemyHero.x))*9, vy:Math.sin(Math.atan2(player.y-enemyHero.y, player.x-enemyHero.x))*9, dmg:40, r:5, c:'red', team:'red', life:30});
                     enemyHero.cds.AA = 50;
                }
            }

            // å•ä½é€»è¾‘
            units.forEach((u, i) => {
                if(u.dead) { units.splice(i,1); return; }
                u.attackCd = (u.attackCd||0) - 1;
                let t = getNearest(u.x, u.y, 300, u.team);
                if(t) {
                    if(Math.hypot(t.x-u.x, t.y-u.y) < 120) {
                        if(u.attackCd<=0) { projectiles.push({x:u.x, y:u.y, vx:Math.cos(Math.atan2(t.y-u.y, t.x-u.x))*6, vy:Math.sin(Math.atan2(t.y-u.y, t.x-u.x))*6, dmg:15, r:3, c:u.color, team:u.team, life:30}); u.attackCd=90; }
                    } else { u.x+=(t.x-u.x)*0.01; u.y+=(t.y-u.y)*0.01; }
                } else { let dx = u.team==='blue'?redTower.x:blueTower.x; u.x += Math.sign(dx-u.x)*2; }
            });

            // æŠ•å°„ç‰©
            projectiles.forEach((p, i) => {
                p.x+=p.vx; p.y+=p.vy; p.life--;
                let t = getCollision(p.x, p.y, p.r, p.team);
                if(t) { t.takeDamage(p.dmg); p.life=0; }
                if(p.life<=0) projectiles.splice(i,1);
            });

            // ç‰¹æ•ˆå¤„ç†
            effects.forEach((e, i) => {
                if(e.type==='area') {
                    e.timer--; if(e.timer<=0 && !e.done) { e.done=true; dealArea(e.x, e.y, e.r, e.dmg, e.team); effects.push({x:e.x, y:e.y, r:e.r, c:e.c, life:15, type:'explode'}); }
                } else if(e.type==='laser') {
                     if(e.life===15) getAllEnemies(e.team).forEach(t=>{ if(Math.hypot(t.x-e.x, t.y-e.y)<2000 && Math.abs(Math.atan2(t.y-e.y, t.x-e.x)-e.a)<0.2) t.takeDamage(e.dmg, true); });
                     e.life--;
                } else e.life--;
                if(e.life<=0 || (e.done && e.type==='area')) if(e.type!=='area' || e.done) effects.splice(i,1);
            });
            
            damageTexts.forEach((d,i) => {d.y-=1; d.life--; if(d.life<=0) damageTexts.splice(i,1);});

            // èƒœè´Ÿ
            if(redTower.dead || blueTower.dead) {
                gameState = 'END';
                document.getElementById('end-screen').classList.remove('hidden');
                document.getElementById('end-msg').innerText = redTower.dead ? "èƒœåˆ©ï¼" : "å¤±è´¥ï¼";
                document.getElementById('end-msg').style.color = redTower.dead ? "#2ecc71" : "#e74c3c";
            }

            // å¤æ´»
            if(player.dead && Math.random()<0.01) { player.hp=player.maxHp; player.dead=false; player.x=blueTower.x; player.y=blueTower.y; }
            if(enemyHero.dead && Math.random()<0.01) { enemyHero.hp=enemyHero.maxHp; enemyHero.dead=false; enemyHero.x=redTower.x; enemyHero.y=redTower.y; }
        }

        function draw() {
            ctx.fillStyle = '#161616'; ctx.fillRect(0,0,canvas.width,canvas.height);
            // åœ°é¢ä¸­çº¿
            ctx.strokeStyle='#333'; ctx.beginPath(); ctx.moveTo(0, canvas.height/2); ctx.lineTo(canvas.width, canvas.height/2); ctx.stroke();

            // ç»˜åˆ¶æ‰€æœ‰ç‰©ä½“
            [blueTower, redTower].forEach(t => { 
                if(!t.dead) {
                    ctx.fillStyle='#333'; ctx.fillRect(t.x-25,t.y-25,50,50);
                    ctx.fillStyle=t.color; ctx.beginPath(); ctx.arc(t.x,t.y,20,0,Math.PI*2); ctx.fill();
                    t.drawHp(ctx);
                }
            });
            
            units.forEach(u => { ctx.fillStyle=u.color; ctx.beginPath(); ctx.arc(u.x,u.y,10,0,Math.PI*2); ctx.fill(); });
            if(!player.dead) player.draw(ctx);
            if(!enemyHero.dead) enemyHero.draw(ctx);
            
            projectiles.forEach(p => { ctx.fillStyle=p.c; ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill(); });
            
            effects.forEach(e => {
                if(e.type==='explode') { ctx.globalAlpha=e.life/15; ctx.fillStyle=e.c; ctx.beginPath(); ctx.arc(e.x,e.y,e.r,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; }
                if(e.type==='slash') { ctx.save(); ctx.translate(e.x, e.y); ctx.rotate(e.a); ctx.strokeStyle='white'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(0,0,60,-0.5,0.5); ctx.stroke(); ctx.restore(); }
                if(e.type==='area' && !e.done) { ctx.strokeStyle=e.c; ctx.beginPath(); ctx.arc(e.x,e.y,e.r,0,Math.PI*2); ctx.stroke(); ctx.fillStyle='rgba(255,255,255,0.2)'; ctx.fill(); }
                if(e.type==='laser') { ctx.save(); ctx.translate(e.x, e.y); ctx.rotate(e.a); ctx.fillStyle='rgba(255,255,255,0.6)'; ctx.fillRect(0,-10,2000,20); ctx.restore(); }
            });

            damageTexts.forEach(d => { ctx.fillStyle=d.c?'#ffeb3b':'#fff'; ctx.font='bold 14px sans-serif'; ctx.fillText(Math.floor(d.n), d.x, d.y); });

            document.getElementById('hp-blue-tower').innerText = Math.floor(blueTower.hp);
            document.getElementById('hp-red-tower').innerText = Math.floor(redTower.hp);
        }

        function loop() {
            if(gameState === 'PLAYING') {
                updateGame();
                draw();
                animationId = requestAnimationFrame(loop);
            }
        }

        // --- è¾…åŠ© ---
        function getAllEnemies(myTeam) {
            let arr = [];
            if(myTeam==='blue') { if(!redTower.dead)arr.push(redTower); if(!enemyHero.dead)arr.push(enemyHero); units.forEach(u=>{if(u.team==='red')arr.push(u)}); }
            else { if(!blueTower.dead)arr.push(blueTower); if(!player.dead)arr.push(player); units.forEach(u=>{if(u.team==='blue')arr.push(u)}); }
            return arr;
        }
        function getNearest(x, y, range, myTeam) {
            let min=range, res=null;
            getAllEnemies(myTeam).forEach(t => { let d=Math.hypot(t.x-x, t.y-y); if(d<min){min=d; res=t;} });
            return res;
        }
        function getCollision(x, y, r, myTeam) {
            for(let t of getAllEnemies(myTeam)) if(Math.hypot(t.x-x, t.y-y) < r+t.radius) return t;
            return null;
        }
        function dealArea(x, y, r, dmg, myTeam) {
            getAllEnemies(myTeam).forEach(t => { if(Math.hypot(t.x-x, t.y-y) < r+t.radius) t.takeDamage(dmg); });
        }

        // --- æµç¨‹æ§åˆ¶ ---
        function startGame(type) {
            currentHeroType = type;
            resetGameVars();
            
            document.getElementById('selection-screen').classList.add('hidden');
            document.getElementById('game-ui').classList.remove('hidden');
            
            // è®¾ç½®å›¾æ ‡
            for(let k in HERO_DATA[type].icons) document.getElementById(`cd-${k.toLowerCase()}-mob`).parentNode.firstChild.textContent = HERO_DATA[type].icons[k];
            
            gameState = 'PLAYING';
            loop();
        }

        function resetGameVars() {
            blueTower = {x:80, y:canvas.height/2, hp:5000, maxHp:5000, team:'blue', color:'#3498db', radius:40, timer:0, atkTimer:0, dead:false, drawHp: Unit.prototype.drawHp};
            redTower = {x:canvas.width-80, y:canvas.height/2, hp:5000, maxHp:5000, team:'red', color:'#e74c3c', radius:40, timer:0, atkTimer:0, dead:false, drawHp: Unit.prototype.drawHp};
            
            player = new Player(150, canvas.height/2, 'blue', HERO_DATA[currentHeroType]);
            enemyHero = new Hero(canvas.width-150, canvas.height/2, 'red', HERO_DATA['warrior']); // é»˜è®¤æ•Œäººæˆ˜å£«
            
            units = []; projectiles = []; effects = []; damageTexts = [];
        }

        function goHome() {
            gameState = 'MENU';
            cancelAnimationFrame(animationId);
            document.getElementById('game-ui').classList.add('hidden');
            document.getElementById('end-screen').classList.add('hidden');
            document.getElementById('selection-screen').classList.remove('hidden');
        }

        function restartGame() {
            document.getElementById('end-screen').classList.add('hidden');
            startGame(currentHeroType);
        }

        // --- è§¦å±äº‹ä»¶ ---
        const jz = document.getElementById('joystick-zone');
        const js = document.getElementById('joystick-stick');
        jz.addEventListener('touchstart', e => {
            e.preventDefault();
            const t = e.changedTouches[0];
            const rect = jz.getBoundingClientRect();
            joystick = { active:true, startX: rect.left+rect.width/2, startY: rect.top+rect.height/2, dx:0, dy:0, angle:0 };
            updateJoy(t);
        });
        jz.addEventListener('touchmove', e => { e.preventDefault(); if(joystick.active) updateJoy(e.changedTouches[0]); });
        const endJoy = e => { e.preventDefault(); joystick.active=false; js.style.transform=`translate(-50%,-50%)`; };
        jz.addEventListener('touchend', endJoy); jz.addEventListener('touchcancel', endJoy);

        function updateJoy(t) {
            let dx = t.clientX - joystick.startX, dy = t.clientY - joystick.startY;
            let dist = Math.min(50, Math.hypot(dx, dy));
            let angle = Math.atan2(dy, dx);
            joystick.dx = Math.cos(angle); joystick.dy = Math.sin(angle); joystick.angle = angle;
            js.style.transform = `translate(calc(-50% + ${joystick.dx*dist}px), calc(-50% + ${joystick.dy*dist}px))`;
        }

        window.handleSkillTouch = function(e, key) {
            e.preventDefault();
            if(player.dead) return;
            let t = getNearest(player.x, player.y, 500, player.team);
            let tx = t ? t.x : player.x + Math.cos(player.facing)*200;
            let ty = t ? t.y : player.y + Math.sin(player.facing)*200;
            player.cast(key, tx, ty);
        };
    </script>
</body>
</html>
