<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <!-- æ ¸å¿ƒä¼˜åŒ–ï¼šç¦æ­¢ç¼©æ”¾ï¼Œå¼ºåˆ¶æ¨ªå±æ¯”ä¾‹ï¼Œé€‚é…ç§»åŠ¨ç«¯ -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Web MOBA: æ‰‹æœºè§¦å±ç‰ˆ</title>
    <style>
        * {
            touch-action: none; /* ç¦æ­¢æµè§ˆå™¨é»˜è®¤çš„æ»‘åŠ¨è¡Œä¸º */
            user-select: none;  /* ç¦æ­¢é•¿æŒ‰é€‰ä¸­æ–‡å­— */
            -webkit-user-select: none;
        }
        body {
            margin: 0;
            overflow: hidden;
            background-color: #121212;
            font-family: 'Segoe UI', sans-serif;
            color: white;
        }
        canvas { display: block; }

        /* UI è¦†ç›–å±‚ */
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100;
        }
        .hidden { display: none !important; }
        
        h1 { font-size: 30px; color: #ffd700; text-shadow: 0 0 10px #ff6b6b; margin-bottom: 20px; text-align: center;}
        
        /* è‹±é›„é€‰æ‹©å¡ç‰‡ (é€‚é…æ‰‹æœºæ¨ªæ’) */
        .hero-container { display: flex; gap: 15px; flex-wrap: wrap; justify-content: center;}
        .hero-card {
            width: 100px; background: #222; border: 2px solid #444; border-radius: 8px;
            padding: 10px; text-align: center; transition: 0.2s;
        }
        .hero-card:active { transform: scale(0.95); background: #333; border-color: #fff; }
        .hero-shape {
            width: 40px; height: 40px; margin: 0 auto 10px;
            display: flex; align-items: center; justify-content: center; font-size: 20px;
        }
        
        /* --- ç§»åŠ¨ç«¯æ§åˆ¶å™¨æ ·å¼ --- */
        
        /* å·¦ä¾§æ‘‡æ†åŒºåŸŸ */
        #joystick-zone {
            position: absolute; bottom: 40px; left: 40px;
            width: 150px; height: 150px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.2);
            pointer-events: auto; /* å…è®¸è§¦æ‘¸ */
        }
        #joystick-stick {
            position: absolute; top: 50%; left: 50%;
            width: 60px; height: 60px;
            background: rgba(78, 205, 196, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(78, 205, 196, 0.8);
            pointer-events: none; /* è®©è§¦æ‘¸ç©¿é€åˆ° zone */
        }

        /* å³ä¾§æŠ€èƒ½æŒ‰é’®åŒºåŸŸ */
        #skill-zone {
            position: absolute; bottom: 30px; right: 30px;
            display: flex; gap: 15px;
            align-items: flex-end;
        }
        .mobile-skill-btn {
            width: 60px; height: 60px;
            background: #222;
            border: 2px solid #555;
            border-radius: 50%;
            color: white;
            font-size: 18px;
            display: flex; justify-content: center; align-items: center;
            position: relative;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        .mobile-skill-btn:active { background: #444; transform: scale(0.95); }
        /* å¤§æ‹›æŒ‰é’®ç¨å¾®å¤§ä¸€ç‚¹ */
        .btn-r { width: 75px; height: 75px; border-color: #ffd700; background: #332a00;}
        
        .skill-cooldown {
            position: absolute; top:0; left:0; width: 100%; height: 100%;
            border-radius: 50%;
            background: rgba(0,0,0,0.7);
            display: flex; justify-content: center; align-items: center;
            font-size: 20px; color: #fff;
            display: none;
        }

        /* é¡¶éƒ¨è¡€æ¡ HUD */
        #hud-top {
            position: absolute; top: 10px; left: 0; width: 100%;
            display: flex; justify-content: space-between; padding: 0 20px; box-sizing: border-box;
            font-weight: bold; font-size: 14px; pointer-events: none;
            text-shadow: 1px 1px 2px black;
        }
        .team-blue { color: #4ecdc4; }
        .team-red { color: #e74c3c; }
        
        .btn { padding: 10px 30px; font-size: 20px; background: #4CAF50; border: none; color: white; border-radius: 8px; margin-top: 20px;}
        
        #rotate-tip {
            display: none; position: absolute; top:0; left:0; width:100%; height:100%; 
            background: black; z-index: 999; color: white; 
            align-items: center; justify-content: center; text-align: center;
        }
        /* ç«–å±æ—¶æç¤ºæ—‹è½¬ */
        @media screen and (orientation: portrait) {
            #rotate-tip { display: flex; }
        }
    </style>
</head>
<body>

    <div id="rotate-tip">
        <div>è¯·å°†æ‰‹æœºæ¨ªå±æ¸¸ç©<br>ğŸ“±ğŸ”„</div>
    </div>

    <!-- è‹±é›„é€‰æ‹© -->
    <div id="selection-screen" class="overlay">
        <h1>é€‰æ‹©è‹±é›„</h1>
        <div class="hero-container">
            <div class="hero-card" onclick="startGame('mage')">
                <div class="hero-shape" style="background:#3498db; border-radius:50%;">ğŸ”µ</div>
                <h4>æ³•å¸ˆ</h4>
            </div>
            <div class="hero-card" onclick="startGame('shooter')">
                <div class="hero-shape" style="background:transparent;"><div style="border-bottom: 30px solid #2ecc71; border-left: 15px solid transparent; border-right: 15px solid transparent;"></div></div>
                <h4>å°„æ‰‹</h4>
            </div>
            <div class="hero-card" onclick="startGame('warrior')">
                <div class="hero-shape" style="background:#e74c3c; width:30px; height:30px;"></div>
                <h4>æˆ˜å£«</h4>
            </div>
        </div>
    </div>

    <!-- æ¸¸æˆç»“æŸ -->
    <div id="end-screen" class="overlay hidden">
        <h1 id="end-msg">ç»“æŸ</h1>
        <button class="btn" onclick="location.reload()">å†æ¥ä¸€å±€</button>
    </div>

    <!-- æ¸¸æˆ HUD -->
    <div id="game-ui" class="hidden">
        <div id="hud-top">
            <div class="team-blue">æˆ‘å¡”: <span id="hp-blue-tower">5000</span></div>
            <div class="team-red">æ•Œå¡”: <span id="hp-red-tower">5000</span></div>
        </div>
        
        <!-- è™šæ‹Ÿæ‘‡æ† -->
        <div id="joystick-zone">
            <div id="joystick-stick"></div>
        </div>

        <!-- æŠ€èƒ½æŒ‰é’® -->
        <div id="skill-zone">
            <!-- Q -->
            <div class="mobile-skill-btn" ontouchstart="handleSkillTouch(event, 'Q')">
                <span id="icon-q">Q</span>
                <div id="cd-q-mob" class="skill-cooldown"></div>
            </div>
            <!-- W -->
            <div class="mobile-skill-btn" ontouchstart="handleSkillTouch(event, 'W')">
                <span id="icon-w">W</span>
                <div id="cd-w-mob" class="skill-cooldown"></div>
            </div>
            <!-- E -->
            <div class="mobile-skill-btn" ontouchstart="handleSkillTouch(event, 'E')">
                <span id="icon-e">E</span>
                <div id="cd-e-mob" class="skill-cooldown"></div>
            </div>
            <!-- R (å¤§æ‹›) -->
            <div class="mobile-skill-btn btn-r" ontouchstart="handleSkillTouch(event, 'R')">
                <span id="icon-r">R</span>
                <div id="cd-r-mob" class="skill-cooldown"></div>
            </div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // --- å…¨å±€å˜é‡ ---
        let gameState = 'MENU';
        let player, enemyHero, blueTower, redTower;
        let units = [], projectiles = [], effects = [], damageTexts = [];
        
        // æ‘‡æ†çŠ¶æ€
        let joystick = { active: false, startX: 0, startY: 0, dx: 0, dy: 0, angle: 0 };

        // --- è¾…åŠ©å‡½æ•° ---
        const dist = (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1);
        const angleTo = (x1, y1, x2, y2) => Math.atan2(y2 - y1, x2 - x1);

        // --- è‹±é›„é…ç½® ---
        const HERO_DATA = {
            mage: {
                type: 'mage', hp: 900, speed: 4.5, radius: 25, range: 220,
                icons: {Q:'ğŸ”¥', W:'âš¡', E:'ğŸ’¥', R:'ğŸŒŸ'}, cd: {Q:40, W:300, E:180, R:600}
            },
            shooter: {
                type: 'shooter', hp: 700, speed: 5.0, radius: 25, range: 380,
                icons: {Q:'ğŸ¹', W:'ğŸ‘Ÿ', E:'ğŸ”«', R:'ğŸ¯'}, cd: {Q:20, W:180, E:300, R:900}
            },
            warrior: {
                type: 'warrior', hp: 1600, speed: 4.8, radius: 30, range: 80,
                icons: {Q:'ğŸª“', W:'ğŸƒ', E:'ğŸŒªï¸', R:'ğŸŒ‹'}, cd: {Q:30, W:240, E:360, R:700}
            }
        };

        // --- æ¸¸æˆå¯¹è±¡ç±» ---
        class GameObject {
            constructor(x, y, r, color, team) {
                this.x = x; this.y = y; this.radius = r; this.color = color; this.team = team;
                this.dead = false;
            }
        }

        class Unit extends GameObject {
            constructor(x, y, r, color, team, hp, maxHp) {
                super(x, y, r, color, team);
                this.maxHp = maxHp || hp; this.hp = hp;
            }
            drawHp(ctx) {
                const w = 30, h = 4;
                const pct = Math.max(0, this.hp / this.maxHp);
                ctx.fillStyle = '#222'; ctx.fillRect(this.x - w/2, this.y - this.radius - 10, w, h);
                ctx.fillStyle = this.team === 'blue' ? '#4ecdc4' : '#e74c3c';
                ctx.fillRect(this.x - w/2, this.y - this.radius - 10, w * pct, h);
            }
            takeDamage(amt, isCrit=false) {
                if(this.dead) return;
                this.hp -= amt;
                damageTexts.push(new DamageText(this.x, this.y - 30, amt, isCrit));
                if (this.hp <= 0) {
                    this.dead = true; this.hp = 0;
                    effects.push(new Explosion(this.x, this.y, this.radius*1.5, this.color));
                }
            }
        }

        class Hero extends Unit {
            constructor(x, y, team, config) {
                super(x, y, config.radius, team==='blue'? '#3498db':'#e74c3c', team, config.hp);
                this.config = config;
                this.facingAngle = 0; // è®°å½•æœå‘
                this.cooldowns = {Q:0, W:0, E:0, R:0, AA:0};
            }
            
            updateCooldowns() { for(let k in this.cooldowns) if(this.cooldowns[k]>0) this.cooldowns[k]--; }

            castSkill(key, mx, my) {
                if (this.cooldowns[key] > 0) return;
                const a = angleTo(this.x, this.y, mx, my);
                const cfg = this.config;

                // Q
                if (key === 'Q') {
                    if (cfg.type === 'mage') projectiles.push(new Projectile(this.x, this.y, a, 12, 120, '#ff0', this.team, 15));
                    else if (cfg.type === 'shooter') projectiles.push(new Projectile(this.x, this.y, a, 18, 90, '#aff', this.team, 6));
                    else if (cfg.type === 'warrior') {
                        effects.push(new MeleeSlash(this.x, this.y, a));
                        dealAreaDamage(this.x + Math.cos(a)*60, this.y + Math.sin(a)*60, 80, 100, this.team);
                    }
                } 
                // W (ä½ç§»)
                else if (key === 'W') {
                    let d = cfg.type==='warrior'?250 : 180;
                    if(cfg.type==='mage') d=220;
                    this.x += Math.cos(a)*d; this.y += Math.sin(a)*d; 
                    effects.push(new Explosion(this.x, this.y, 30, '#fff', 10));
                }
                // E
                else if (key === 'E') {
                    if (cfg.type === 'mage') effects.push(new AreaDelay(mx, my, 90, '#ffe66d', 140, this.team));
                    else if (cfg.type === 'shooter') {
                         for(let i=-1; i<=1; i++) projectiles.push(new Projectile(this.x, this.y, a+i*0.3, 12, 40, '#0f0', this.team));
                    }
                    else if (cfg.type === 'warrior') dealAreaDamage(this.x, this.y, 120, 60, this.team);
                }
                // R
                else if (key === 'R') {
                    if (cfg.type === 'mage') effects.push(new Laser(this.x, this.y, a, 350, this.team));
                    else if (cfg.type === 'shooter') projectiles.push(new Projectile(this.x, this.y, a, 35, 450, '#f0f', this.team, 10));
                    else if (cfg.type === 'warrior') effects.push(new AreaDelay(this.x, this.y, 220, '#8B4513', 350, this.team));
                }
                this.cooldowns[key] = cfg.cd[key];
            }
            
            tryAutoAttack() {
                if (this.cooldowns.AA <= 0) {
                    let target = getNearestEnemy(this.x, this.y, this.config.range, this.team);
                    if (target) {
                        if(this.config.type==='warrior') {
                            effects.push(new MeleeSlash(this.x, this.y, angleTo(this.x,this.y,target.x,target.y)));
                            target.takeDamage(60);
                        } else {
                            projectiles.push(new Projectile(this.x, this.y, angleTo(this.x,this.y,target.x,target.y), 9, 45, this.color, this.team));
                        }
                        this.cooldowns.AA = (this.config.type==='shooter'? 25 : 50);
                    }
                }
            }

            draw(ctx) {
                ctx.save(); ctx.translate(this.x, this.y);
                // æŒ‡ç¤ºæ–¹å‘çš„å°ç®­å¤´
                ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(this.facingAngle)*35, Math.sin(this.facingAngle)*35); 
                ctx.strokeStyle='rgba(255,255,255,0.5)'; ctx.lineWidth=2; ctx.stroke();

                ctx.fillStyle = this.color; ctx.strokeStyle = 'white'; ctx.lineWidth = 2;
                if (this.config.type === 'mage') { ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI*2); ctx.fill(); ctx.stroke(); } 
                else if (this.config.type === 'shooter') { ctx.beginPath(); ctx.moveTo(15, 0); ctx.lineTo(-10, 10); ctx.lineTo(-10, -10); ctx.closePath(); ctx.fill(); ctx.stroke(); } 
                else { ctx.fillRect(-this.radius, -this.radius, this.radius*2, this.radius*2); ctx.strokeRect(-this.radius, -this.radius, this.radius*2, this.radius*2); }
                ctx.restore();
                this.drawHp(ctx);
                ctx.fillStyle = 'white'; ctx.font = "10px sans-serif"; ctx.textAlign = "center";
                ctx.fillText(this.team==='blue'?"æˆ‘":"æ•Œ", this.x, this.y - 35);
            }
        }

        // --- ç©å®¶ç±» (æ‘‡æ†æ§åˆ¶) ---
        class Player extends Hero {
            update() {
                if(this.dead) return;
                this.updateCooldowns();
                
                // æ‘‡æ†ç§»åŠ¨é€»è¾‘
                if (joystick.active) {
                    this.x += joystick.dx * this.config.speed;
                    this.y += joystick.dy * this.config.speed;
                    this.facingAngle = joystick.angle; // æ›´æ–°æœå‘

                    // è¾¹ç•Œé™åˆ¶
                    this.x = Math.max(20, Math.min(canvas.width-20, this.x));
                    this.y = Math.max(20, Math.min(canvas.height-20, this.y));
                }

                this.tryAutoAttack();
                
                // æ›´æ–°æŠ€èƒ½CDé®ç½©
                ['Q','W','E','R'].forEach(k => {
                    const el = document.getElementById(`cd-${k.toLowerCase()}-mob`);
                    if(this.cooldowns[k] > 0) {
                        el.style.display = 'flex';
                        el.innerText = Math.ceil(this.cooldowns[k]/60);
                    } else {
                        el.style.display = 'none';
                    }
                });
            }
        }

        // --- AI è‹±é›„ ---
        class EnemyHero extends Hero {
            constructor(x, y, config) {
                super(x, y, 'red', config);
                this.state = 'IDLE'; this.aiTimer = 0;
                this.targetX = x; this.targetY = y;
            }
            update() {
                if (this.dead) return;
                this.updateCooldowns(); this.aiTimer++;

                let dToPlayer = dist(this.x, this.y, player.x, player.y);
                let dToHome = dist(this.x, this.y, redTower.x, redTower.y);
                
                if (this.hp < this.maxHp * 0.3) this.state = 'RETREAT';
                else if (dToPlayer < 600) this.state = 'CHASE';
                else this.state = 'IDLE';

                if (this.state === 'RETREAT') { this.targetX = redTower.x - 100; this.targetY = redTower.y; } 
                else if (this.state === 'CHASE') {
                    let ideal = this.config.type === 'warrior' ? 50 : 300;
                    if (dToPlayer > ideal) { this.targetX = player.x; this.targetY = player.y; } 
                    else { if(this.aiTimer%60===0){this.targetX=this.x+(Math.random()-0.5)*200;this.targetY=this.y+(Math.random()-0.5)*200;} }
                    // æ–½æ³•
                    if(this.aiTimer%45===0) {
                         if (dToPlayer < 800 && Math.random() < 0.4) this.castSkill('Q', player.x, player.y);
                         if (dToPlayer < 300 && Math.random() < 0.2) this.castSkill('E', player.x, player.y);
                         if (dToPlayer < 700 && dToPlayer > 200 && Math.random() < 0.1) this.castSkill('R', player.x, player.y);
                    }
                } 
                else { // IDLE
                    if(this.aiTimer%120===0) {this.targetX = canvas.width/2 + (Math.random()-0.5)*300; this.targetY = canvas.height/2 + (Math.random()-0.5)*300;}
                }

                // ç§»åŠ¨
                if (dist(this.x, this.y, this.targetX, this.targetY) > this.config.speed) {
                    const a = angleTo(this.x, this.y, this.targetX, this.targetY);
                    this.x += Math.cos(a) * this.config.speed;
                    this.y += Math.sin(a) * this.config.speed;
                    this.facingAngle = a;
                }
                this.tryAutoAttack();
            }
        }

        // --- é˜²å¾¡å¡”ä¸å°å…µ ---
        class Tower extends Unit {
            constructor(team) {
                let x = team === 'blue' ? 80 : canvas.width - 80;
                super(x, canvas.height/2, 50, team==='blue'?'#3498db':'#e74c3c', team, 5000);
                this.spawnTimer = 0; this.attackTimer = 0;
            }
            update() {
                if (this.dead) return;
                this.spawnTimer++;
                if (this.spawnTimer > 300) {
                    for(let i=0; i<3; i++) units.push(new Minion(this.x, this.y + (i-1)*30, this.team));
                    this.spawnTimer = 0;
                }
                this.attackTimer--;
                if (this.attackTimer <= 0) {
                    let target = getNearestEnemy(this.x, this.y, 400, this.team);
                    if (target) {
                        projectiles.push(new Projectile(this.x, this.y, angleTo(this.x,this.y,target.x,target.y), 8, 150, this.color, this.team, 8));
                        this.attackTimer = 60;
                    }
                }
            }
            draw(ctx) {
                if(this.dead) return;
                ctx.fillStyle = '#333'; ctx.fillRect(this.x-25, this.y-25, 50, 50);
                ctx.beginPath(); ctx.arc(this.x, this.y, 20, 0, Math.PI*2); ctx.fillStyle=this.color; ctx.fill();
                ctx.beginPath(); ctx.arc(this.x, this.y, 400, 0, Math.PI*2); ctx.strokeStyle=this.team==='blue'?'rgba(0,200,255,0.1)':'rgba(255,0,0,0.1)'; ctx.stroke();
                this.drawHp(ctx);
            }
        }

        class Minion extends Unit {
            constructor(x, y, team) {
                super(x, y, 10, team==='blue'?'#4ecdc4':'#ff6b6b', team, 150);
                this.speed = 2.5; this.range = 120; this.attackCd = 0;
            }
            update() {
                if (this.dead) return;
                this.attackCd--;
                let target = getNearestEnemy(this.x, this.y, 300, this.team);
                if (target) {
                    if (dist(this.x, this.y, target.x, target.y) <= this.range) {
                        if (this.attackCd <= 0) {
                             projectiles.push(new Projectile(this.x, this.y, angleTo(this.x,this.y,target.x,target.y), 6, 15, this.color, this.team, 3));
                             this.attackCd = 90;
                        }
                    } else {
                        let a = angleTo(this.x, this.y, target.x, target.y);
                        this.x += Math.cos(a) * this.speed; this.y += Math.sin(a) * this.speed;
                    }
                } else {
                    let destX = this.team === 'blue' ? redTower.x : blueTower.x;
                    let a = angleTo(this.x, this.y, destX, canvas.height/2);
                    this.x += Math.cos(a) * this.speed; this.y += Math.sin(a) * this.speed * 0.3;
                }
            }
            draw(ctx) {
                ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fillStyle = this.color; ctx.fill();
            }
        }

        class Projectile extends GameObject {
            constructor(x, y, angle, speed, dmg, color, team, radius=5) {
                super(x, y, radius, color, team);
                this.vx = Math.cos(angle)*speed; this.vy = Math.sin(angle)*speed; this.dmg = dmg; this.life = 120;
            }
            update() {
                this.x += this.vx; this.y += this.vy; this.life--;
                let target = getCollision(this.x, this.y, this.radius, this.team);
                if (target) { target.takeDamage(this.dmg); this.life = 0; }
            }
            draw(ctx) { ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fillStyle = this.color; ctx.fill(); }
        }

        class AreaDelay { 
            constructor(x,y,r,c,dmg,team) { this.x=x;this.y=y;this.r=r;this.c=c;this.dmg=dmg;this.team=team; this.timer=40; this.done=false;}
            update() { 
                this.timer--; 
                if(this.timer<=0 && !this.done) {
                    this.done=true; dealAreaDamage(this.x,this.y,this.r,this.dmg,this.team);
                    effects.push(new Explosion(this.x,this.y,this.r,this.c));
                }
            }
            draw(ctx) { if(!this.done) { ctx.beginPath();ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.fillStyle=`rgba(255,255,255,0.3)`;ctx.fill(); ctx.strokeStyle=this.c;ctx.stroke();} }
        }
        class Laser { 
            constructor(x,y,angle,dmg,team) {this.x=x;this.y=y;this.a=angle;this.dmg=dmg;this.team=team;this.life=15; this.deal();}
            deal() { getAllEnemies(this.team).forEach(e => { if(dist(this.x,this.y,e.x,e.y)<2000 && Math.abs(angleTo(this.x,this.y,e.x,e.y)-this.a) < 0.15) e.takeDamage(this.dmg, true); }); }
            update(){this.life--;} draw(ctx){ctx.save();ctx.translate(this.x,this.y);ctx.rotate(this.a);ctx.fillStyle='rgba(255,255,255,0.6)';ctx.fillRect(0,-15,2000,30);ctx.restore();}
        }
        class Explosion { constructor(x,y,r,c){this.x=x;this.y=y;this.r=r;this.c=c;this.life=15;} update(){this.life--;} draw(ctx){ctx.globalAlpha=this.life/15;ctx.beginPath();ctx.arc(this.x,this.y,this.r,0,Math.PI*2);ctx.fillStyle=this.c;ctx.fill();ctx.globalAlpha=1;} }
        class MeleeSlash { constructor(x,y,a){this.x=x;this.y=y;this.a=a;this.life=10;} update(){this.life--;} draw(ctx){ctx.save();ctx.translate(this.x,this.y);ctx.rotate(this.a);ctx.beginPath();ctx.arc(0,0,60,-0.5,0.5);ctx.strokeStyle='white';ctx.lineWidth=5;ctx.stroke();ctx.restore();}}
        class DamageText { constructor(x,y,n,c){this.x=x;this.y=y;this.n=n;this.c=c;this.life=30;} update(){this.y-=1;this.life--;} draw(ctx){ctx.fillStyle=this.c?'#ffeb3b':'#fff';ctx.font="bold 14px sans-serif";ctx.fillText(Math.floor(this.n),this.x,this.y);} }

        // --- é€šç”¨é€»è¾‘ ---
        function getAllEnemies(myTeam) {
            let targets = [];
            if (myTeam === 'blue') { if(!redTower.dead) targets.push(redTower); if(!enemyHero.dead) targets.push(enemyHero); }
            else { if(!blueTower.dead) targets.push(blueTower); if(!player.dead) targets.push(player); }
            units.forEach(u => { if(!u.dead && u.team !== myTeam) targets.push(u); });
            return targets;
        }
        function getNearestEnemy(x, y, range, myTeam) {
            let targets = getAllEnemies(myTeam);
            let minD = range, found = null;
            targets.forEach(t => { let d = dist(x, y, t.x, t.y); if(d < minD) { minD = d; found = t; } });
            return found;
        }
        function getCollision(x, y, r, myTeam) {
            for(let t of getAllEnemies(myTeam)) { if(dist(x,y,t.x,t.y) < r + t.radius) return t; } return null;
        }
        function dealAreaDamage(x, y, r, dmg, myTeam) {
            getAllEnemies(myTeam).forEach(t => { if(dist(x,y,t.x,t.y) < r + t.radius) t.takeDamage(dmg); });
        }

        // --- è§¦å±æ§åˆ¶é€»è¾‘ ---
        
        // æ‘‡æ†å¤„ç†
        const joystickZone = document.getElementById('joystick-zone');
        const stick = document.getElementById('joystick-stick');

        joystickZone.addEventListener('touchstart', e => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            const rect = joystickZone.getBoundingClientRect();
            // è®°å½•ä¸­å¿ƒç‚¹
            joystick.startX = rect.left + rect.width/2;
            joystick.startY = rect.top + rect.height/2;
            joystick.active = true;
            updateJoystick(touch);
        });

        joystickZone.addEventListener('touchmove', e => {
            e.preventDefault();
            if(joystick.active) updateJoystick(e.changedTouches[0]);
        });

        const endJoystick = (e) => {
            e.preventDefault();
            joystick.active = false;
            joystick.dx = 0; joystick.dy = 0;
            stick.style.transform = `translate(-50%, -50%)`;
        };
        joystickZone.addEventListener('touchend', endJoystick);
        joystickZone.addEventListener('touchcancel', endJoystick);

        function updateJoystick(touch) {
            let dx = touch.clientX - joystick.startX;
            let dy = touch.clientY - joystick.startY;
            const distance = Math.min(50, Math.hypot(dx, dy)); // æœ€å¤§åŠå¾„50
            const angle = Math.atan2(dy, dx);
            
            joystick.dx = Math.cos(angle);
            joystick.dy = Math.sin(angle);
            joystick.angle = angle;

            // ç§»åŠ¨Stickè§†è§‰
            stick.style.transform = `translate(calc(-50% + ${Math.cos(angle)*distance}px), calc(-50% + ${Math.sin(angle)*distance}px))`;
        }

        // æŠ€èƒ½æŒ‰é’®å¤„ç† (Smart Cast)
        window.handleSkillTouch = function(e, key) {
            e.preventDefault(); // é˜²æ­¢ç‚¹å‡»ç©¿é€
            if(player.dead) return;
            
            // æ™ºèƒ½æ–½æ³•é€»è¾‘ï¼š
            // 1. ä¼˜å…ˆå¯»æ‰¾èŒƒå›´å†…æœ€è¿‘çš„æ•Œäºº
            let target = getNearestEnemy(player.x, player.y, 500, player.team);
            let tx, ty;
            
            if (target) {
                tx = target.x; ty = target.y;
            } else {
                // 2. æ²¡æœ‰æ•Œäººï¼Œå°±å¾€è‹±é›„é¢å¯¹çš„æ–¹å‘æ”¾
                tx = player.x + Math.cos(player.facingAngle) * 200;
                ty = player.y + Math.sin(player.facingAngle) * 200;
            }
            
            player.castSkill(key, tx, ty);
        };

        // --- æ¸¸æˆä¸»æµç¨‹ ---
        function startGame(heroType) {
            document.getElementById('selection-screen').classList.add('hidden');
            document.getElementById('game-ui').classList.remove('hidden');
            
            blueTower = new Tower('blue'); redTower = new Tower('red');
            player = new Player(150, canvas.height/2, 'blue', HERO_DATA[heroType]);
            const etypes = ['mage','shooter','warrior'];
            enemyHero = new EnemyHero(canvas.width-150, canvas.height/2, HERO_DATA[etypes[Math.floor(Math.random()*3)]]);
            
            // è®¾ç½®å›¾æ ‡
            for(let k in HERO_DATA[heroType].icons) document.getElementById(`icon-${k.toLowerCase()}`).innerText = HERO_DATA[heroType].icons[k];
            
            gameState = 'PLAYING'; loop();
        }

        function loop() {
            if(gameState!=='PLAYING') return;
            requestAnimationFrame(loop);
            
            ctx.fillStyle = '#161616'; ctx.fillRect(0,0,canvas.width,canvas.height);
            
            // æ›´æ–°ä¸ç»˜åˆ¶
            [blueTower, redTower, player, enemyHero].forEach(e => {e.update(); e.draw(ctx);});
            
            units.forEach((u,i) => {u.update(); if(u.dead)units.splice(i,1); else u.draw(ctx);});
            projectiles.forEach((p,i) => {p.update(); if(p.life<=0)projectiles.splice(i,1); else p.draw(ctx);});
            effects.forEach((e,i) => {e.update(); if(e.life<=0 || e.done){if(!(e instanceof AreaDelay)||e.done)effects.splice(i,1);} else e.draw(ctx);});
            damageTexts.forEach((d,i) => {d.update(); if(d.life<=0)damageTexts.splice(i,1); else d.draw(ctx);});

            document.getElementById('hp-blue-tower').innerText = Math.floor(blueTower.hp);
            document.getElementById('hp-red-tower').innerText = Math.floor(redTower.hp);

            // å¤æ´»
            if(player.dead && Math.random()<0.01) { player.hp=player.maxHp; player.dead=false; player.x=blueTower.x; player.y=blueTower.y; }
            if(enemyHero.dead && Math.random()<0.01) { enemyHero.hp=enemyHero.maxHp; enemyHero.dead=false; enemyHero.x=redTower.x; enemyHero.y=redTower.y; }

            if(redTower.dead || blueTower.dead) {
                gameState = 'END';
                document.getElementById('end-screen').classList.remove('hidden');
                document.getElementById('end-msg').innerText = redTower.dead ? "èƒœåˆ©ï¼" : "å¤±è´¥ï¼";
                document.getElementById('end-msg').style.color = redTower.dead ? "#2ecc71" : "#e74c3c";
            }
        }

        window.addEventListener('resize', () => { canvas.width=innerWidth; canvas.height=innerHeight; });
    </script>
</body>
</html>
